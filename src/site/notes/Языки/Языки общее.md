---
{"dg-publish":true,"permalink":"/yazyki/yazyki-obshhee/","dgPassFrontmatter":true}
---


<html>
<head>
    <style>
        .container {
            width: 100%;
            height: 1080px;
            overflow: hidden;
            border: 1px solid gray;
            position: relative;
        }
        .svg-container {
            position: absolute;
            transform-origin: 0 0;
            cursor: grab;
        }
        .svg-container.dragging {
            cursor: grabbing;
        }
    </style>
</head>
<body>
    <div class="container" id="container">
        <div class="svg-container" id="svgContainer">
            <img src="https://raw.githubusercontent.com/Killreal2/dnd_tv_img/refs/heads/main/%D0%AF%D0%B7%D1%8B%D0%BA%D0%B8%20%D0%B8%20%D0%B8%D1%85%20%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5.excalidraw.svg">
        </div>
    </div>

    <script>
        const container = document.getElementById('container');
        const svgContainer = document.getElementById('svgContainer');
        
        let scale = 1;
        let posX = 50;
        let posY = 30;
        let isDragging = false;
        let startPosX = 0;
        let startPosY = 0;
        
        // Применяем текущие трансформации
        function applyTransform() {
            svgContainer.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
        }
        
        // Инициализация
        applyTransform();
        
        // Масштабирование колесиком мыши с зажатым Alt
        container.addEventListener('wheel', (e) => {
            if (e.altKey) {
                e.preventDefault();
                
                // Определяем направление масштабирования
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                
                // Сохраняем позицию мыши относительно контейнера
                const mouseX = e.clientX - container.getBoundingClientRect().left;
                const mouseY = e.clientY - container.getBoundingClientRect().top;
                
                // Вычисляем позицию мыши относительно SVG до масштабирования
                const svgX = (mouseX - posX) / scale;
                const svgY = (mouseY - posY) / scale;
                
                // Изменяем масштаб
                scale = Math.max(0.1, Math.min(scale + delta, 5));
                
                // Пересчитываем позицию, чтобы масштабирование происходило относительно курсора
                posX = mouseX - svgX * scale;
                posY = mouseY - svgY * scale;
                
                applyTransform();
            }
        }, { passive: false });
        
        // Перетаскивание изображения
        svgContainer.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Левая кнопка мыши
                isDragging = true;
                svgContainer.classList.add('dragging');
                startPosX = e.clientX - posX;
                startPosY = e.clientY - posY;
                e.preventDefault();
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                posX = e.clientX - startPosX;
                posY = e.clientY - startPosY;
                applyTransform();
            }
        });
        
        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                isDragging = false;
                svgContainer.classList.remove('dragging');
            }
        });
    </script>
</body>
</html>
  
# Тест

тест